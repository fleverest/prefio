% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preferences.R
\name{preferences}
\alias{preferences}
\alias{[.preferences}
\alias{as.preferences}
\alias{as.preferences.default}
\alias{as.preferences.matrix}
\alias{as.preferences.aggregated_preferences}
\alias{format.preferences}
\title{Preferences Object}
\usage{
preferences(
  data,
  format = c("long", "ordering", "ranking"),
  id = NULL,
  rank = NULL,
  item = NULL,
  item_names = NULL,
  frequencies = NULL,
  aggregate = FALSE,
  verbose = TRUE,
  ...
)

\method{[}{preferences}(x, i, j, ..., drop = FALSE, by.ordering = FALSE)

as.preferences(x, ...)

\method{as.preferences}{default}(
  x,
  format = c("ranking", "long"),
  id = NULL,
  item = NULL,
  rank = NULL,
  item_names = NULL,
  verbose = TRUE
)

\method{as.preferences}{matrix}(
  x,
  format = c("ranking", "long"),
  id = NULL,
  item = NULL,
  rank = NULL,
  item_names = NULL,
  verbose = TRUE
)

\method{as.preferences}{aggregated_preferences}(aggregated_preferences, ...)

\method{format}{preferences}(x, width = 40L, ...)
}
\arguments{
\item{data}{A \code{data.frame} or \code{matrix} in one of three formats:
\describe{
\item{"ordering"}{Orderings must be a \code{data.frame} with \code{"list"}-valued
columns. Each row represents an ordering of the items
from first to last, representing ties by a list of
vectors corresponding to the items.}
\item{"ranking"}{Each row assigns a ranking to each item, each column
gives the rankings assigned to a single item. Rankings
should be dense, otherwise they will be converted to dense
rankings.}
\item{"long"}{Three columns: an \code{id} column grouping the rows which
correspond to a single set of preferences, a
\code{item} column specifying (either by index or by
name) the item each row refers to, and a \code{rank}
column specifying the rank for the associated
\code{item}.}
}}

\item{format}{The format of the data: one of "ordering", "ranking", or
"long". By default, \code{data} is assumed to be in \code{ordering} format.}

\item{id}{For \code{data} in long-format: the column representing the
preference set grouping.}

\item{rank}{For \code{data} in long-format: the column representing the
rank for the associated item.}

\item{item}{For \code{data} in long-format: the column representing
the items by name or by index, in which case the
\code{item_names} parameter should also be passed, or the items will be named as
integers.}

\item{item_names}{The names of the full set of items. When loading data using
integer-valued indices in place of item names, the \code{item_names} character
vector should be in the correct order.}

\item{frequencies}{An optional integer vector containing the number of
occurences of each preference. If provided, the method will return a
\verb{\link{aggregated_preferences}} object with the corresponding
frequencies.}

\item{aggregate}{If \code{TRUE}, aggregate the preferences via
\verb{\link{aggregate.preferences}} before returning. This returns a
\verb{\link{aggregated_preferences}} object.}

\item{i}{The index of the preference-set to access.}

\item{j}{The rank index to access, or if \code{by.ordering = TRUE} the
index or name of the item to obtain the ranking for.}

\item{drop}{If \code{TRUE}, return single row/column matrices as a vector.}

\item{by.ordering}{When \code{FALSE}, returns a \code{"preferences"} object:
internally rows \eqn{i} contain the ranking assigned to each item
in preference \eqn{p_i}. When \code{TRUE}, returns a \code{"data.frame"} where
rows group the the candidates in order of rank.}

\item{width}{The width in number of characters to format each preference,
truncating by "..." when they are too long.}
}
\value{
By default, a \code{"preferences"} object, which is a \code{data.frame} with
\code{"list"}-valued columns corresponding to preferences on the items. This may
be an ordering on subsets of the items in the case of ties, or a
potentially-partial strict ordering. In the case of partial or tied
preferences, some entries may be empty lists.
}
\description{
Create a \code{"preferences"} object for representing Ordinal Preference datasets.
}
\details{
Ordinal preferences can order every item, or they can order a subset. Some
ordinal preference datasets will contain ties between items at a given rank.
Hence, there are four distinct types of preferential data:
\describe{
\item{\code{"soc"}}{Strict Orders - Complete List}
\item{\code{"soi"}}{Strict Orders - Incomplete List}
\item{\code{"toc"}}{Orders with Ties - Complete List}
\item{\code{"toi"}}{Orders with Ties - Incomplete List}
}
The data type is stored alongside the \code{"preferences"} as an attribute
\code{attr(preferences, "preftype")}. The data type is determined automatically.
If every preference ranks every item, then the data type will be
"soc" or "soi". Similarly, if no preference contains a tie the data type
will be "toc" or "toi".

A set of preferences can be represented either by \code{ranking} or by
\code{ordering}. These correspond to the two ways you can list a set of
preferences in a vector:
\describe{
\item{\code{ordering}}{The items are listed in order of most preferred to least
preferred, allowing for pairs of items in the case of
ties.}
\item{\code{ranking}}{The rank assigned to each item is listed in order of some
predefined index on the items. Rankings should be
dense, otherwise they will be converted to dense
rankings.}
}
When reading \code{"preferences"} from an \code{ordering} matrix, the index on the
items is the order passed to the \code{item_names} parameter. When reading from
a \code{rankings} matrix, if no \code{item_names} are provided, the order is inferred
from the named columns.

A \code{"preferences"} object can also be read from a long-format matrix, where
there are three columns: \code{id}, \code{item} and \code{rank}. The \code{id} variable groups
the rows of the matrix which correspond to a single set of preferences, which
the \code{item:rank}, pairs indicate how each item is ranked. When reading a
matrix from this format and no \code{item_names} parameter is passed, the order is
determined automatically.
}
\examples{
# create rankings from data in long form

# Example long-form data
x <- data.frame(id = c(rep(1:4, each = 4), 5, 5, 5),
                item = c(LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,
                           LETTERS[3:5]),
                rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3))

# * Set #1 has two different ranks for the same item (item C
# has rank 1 and 2). This item will be excluded from the preferences.
# * All ranks are missing in set #2, a technically valid partial ordering
# * Some ranks are missing in set #3, a perfectly valid partial ordering
# * Set #4 has inconsistent ranks for two items, and a rank with a
# missing item.
# * Set #5 is not a dense-ranking. It will be converted to be dense and then
# inferred to be a regular partial ordering with ties.
split(x, x$ranking)

# Creating a preferences object with this data will attempt to resolve these
# issues automatically, sending warnings when assumptions need to be made.
preferences(x, id = "id", item = "item", rank = "rank")

# Convert an existing matrix of rankings to a preferences object.
rnk <- matrix(c(1, 2, 0, 0,
                4, 1, 2, 3,
                2, 1, 1, 1,
                1, 2, 3, 0,
                2, 1, 1, 0,
                1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(rnk) <- c("apple", "banana", "orange", "pear")

rnk <- as.preferences(rnk, format = "ranking")

# Convert an existing data.frame of orderings to a preferences object.
ord <- preferences(
  data.frame(
    rank1 = I(list()),
    rank2 = I(list()),
    rank3 = I(list()),
    rank4 = I(list())
  ),
  format = "ordering",
  item_names = c("apple", "banana", "orange", "pear")
)
ord[1,] <- list(1, 2) # apple, banana
ord[2,] <- list("banana", "orange", "pear", "apple")
ord[3,] <- list(c("banana", "orange", "pear"), "apple")
ord[4,] <- list("apple", "banana", "orange")
ord[5,] <- list(c("banana", "orange"), "apple")
ord[6,] <- list("apple", "pear", "orange")

# Alternatively, we could have referred to each item by index and
# passed `item_names = c("apple", "banana", "orange", "pear")`.
ord <- as.preferences(ord)

# Access the first three sets of preferences
ord[1:3, ]

# Truncate preferences to the top 2 ranks
ord[, 1:2, by.ordering = TRUE]

# Exclude pear from the rankings
ord[, -4]

# Get the highest-ranked items from the third preference-set
ord[3, 1, by.ordering = TRUE]

# Get the rank of apple in the third preference-set
ord[3, 1]

# Get all the ranks assiged to apple as a vector
ord[, 1]

# Convert the preferences to a ranking matrix
as.matrix(ord, format = "ranking")

# Convert the preferences to a ordering matrix
as.matrix(ord, format = "ordering")

# Convert the preferences to a long-format matrix
as.matrix(ord, format = "long")

}
